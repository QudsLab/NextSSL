/**
 * @file x448.h
 * @brief Layer 1 (Partial) - X448 (Curve448 ECDH) Interface
 * 
 * @visibility HIDDEN (NEXTSSL_PARTIAL_API)
 * @layer 1
 * @category dhcm
 * @subcategory x448
 * 
 * This interface provides X448 key agreement (Curve448 ECDH) as specified in RFC 7748.
 * X448 is a high-security elliptic curve Diffie-Hellman function.
 * 
 * Security properties:
 * - 224-bit security level (equivalent to AES-224, RSA-14336)
 * - Constant-time implementation (no timing side-channels)
 * - No public key validation required (built-in cofactor clearing)
 * - Higher security than X25519, but slower
 * - Suitable for long-term keys or high-security applications
 * 
 * @warning X448 alone does NOT authenticate parties - combine with signatures (Ed448)
 * @warning Use KDF (e.g., HKDF) to derive session keys from shared secret
 * @warning Never reuse ephemeral keys
 * 
 * Comparison with X25519:
 * - X448: 224-bit security, 56-byte keys, slower (~3x)
 * - X25519: 128-bit security, 32-byte keys, faster
 * - Use X448 for high-security/long-term, X25519 for most applications
 * 
 * Thread safety: All functions are thread-safe (stateless operations).
 */

#ifndef NEXTSSL_PARTIAL_DHCM_X448_H
#define NEXTSSL_PARTIAL_DHCM_X448_H

#include <stddef.h>
#include <stdint.h>
#include "../../config.h"

#ifdef __cplusplus
extern "C" {
#endif

/* ========================================================================
 * X448 Constants
 * ======================================================================== */

#define NEXTSSL_X448_KEY_SIZE     56    /**< X448 key size (private, public, shared) */
#define NEXTSSL_X448_SECRET_SIZE  56    /**< X448 shared secret size */

/* ========================================================================
 * X448 Key Generation
 * ======================================================================== */

/**
 * @brief Generate X448 keypair
 * 
 * @param public_key Output buffer for public key (56 bytes)
 * @param private_key Output buffer for private key (56 bytes)
 * @return 0 on success, negative error code on failure
 * 
 * @warning public_key MUST be 56 bytes
 * @warning private_key MUST be 56 bytes
 * @warning Private key MUST be kept secret and destroyed after use
 * 
 * Key generation:
 * - Private key: 56 random bytes (clamped according to RFC 7748)
 * - Public key: X448(private_key, basepoint=5)
 * 
 * Private key clamping (automatic):
 * - Clear bits 0, 1 of first byte
 * - Clear bit 7 of last byte
 * - Set bit 6 of last byte
 * 
 * @note Uses DRBG for key generation (cryptographically secure)
 * @note Clamping is performed internally - caller receives clamped key
 */
NEXTSSL_PARTIAL_API int
nextssl_partial_dhcm_x448_generate_keypair(
    uint8_t *public_key,
    uint8_t *private_key
);

/**
 * @brief Derive X448 public key from private key
 * 
 * @param public_key Output buffer for public key (56 bytes)
 * @param private_key Private key (56 bytes, must be clamped)
 * @return 0 on success, negative error code on failure
 * 
 * @warning public_key MUST be 56 bytes
 * @warning private_key MUST be 56 bytes and properly clamped
 * 
 * Computation:
 * - public_key = X448(private_key, basepoint=5)
 * 
 * Use case: When you have a stored private key and need to compute public key
 * 
 * @note If private_key was generated by generate_keypair(), it's already clamped
 * @note If loading external key, ensure proper clamping (or use clamp function)
 */
NEXTSSL_PARTIAL_API int
nextssl_partial_dhcm_x448_public_key(
    uint8_t *public_key,
    const uint8_t *private_key
);

/* ========================================================================
 * X448 Key Agreement
 * ======================================================================== */

/**
 * @brief Compute X448 shared secret
 * 
 * @param shared_secret Output buffer for shared secret (56 bytes)
 * @param private_key Our private key (56 bytes, must be clamped)
 * @param peer_public_key Peer's public key (56 bytes)
 * @return 0 on success, negative error code on failure
 * 
 * @warning shared_secret MUST be 56 bytes
 * @warning private_key MUST be 56 bytes and properly clamped
 * @warning peer_public_key MUST be 56 bytes
 * @warning NO public key validation is performed (not needed for X448)
 * @warning ALWAYS use KDF (e.g., HKDF) to derive session keys from shared_secret
 * 
 * Computation:
 * - shared_secret = X448(private_key, peer_public_key)
 * 
 * Error conditions:
 * - Returns error if shared secret is all-zero (contributory behavior failure)
 * - Returns error if inputs are NULL
 * 
 * Security notes:
 * - No public key validation needed (cofactor clearing built-in)
 * - Constant-time implementation (no timing side-channels)
 * - Small-subgroup attacks prevented by clamping + cofactor clearing
 * 
 * Example usage:
 * ```c
 * uint8_t our_private[56], our_public[56];
 * uint8_t peer_public[56], shared_secret[56];
 * 
 * // Generate our keypair
 * nextssl_partial_dhcm_x448_generate_keypair(our_public, our_private);
 * 
 * // Send our_public to peer, receive peer_public
 * 
 * // Compute shared secret
 * nextssl_partial_dhcm_x448_compute(shared_secret, our_private, peer_public);
 * 
 * // Derive session key using HKDF
 * uint8_t session_key[32];
 * nextssl_partial_core_kdf_hkdf(NEXTSSL_HKDF_SHA512,
 *     NULL, 0,  // no salt
 *     shared_secret, 56,
 *     "x448 session key", 16,
 *     session_key, 32);
 * 
 * // Wipe shared secret and private key
 * nextssl_partial_core_buffer_secure_zero(shared_secret, 56);
 * nextssl_partial_core_buffer_secure_zero(our_private, 56);
 * ```
 */
NEXTSSL_PARTIAL_API int
nextssl_partial_dhcm_x448_compute(
    uint8_t *shared_secret,
    const uint8_t *private_key,
    const uint8_t *peer_public_key
);

/* ========================================================================
 * X448 Utility Functions
 * ======================================================================== */

/**
 * @brief Clamp X448 private key according to RFC 7748
 * 
 * @param private_key Private key to clamp (56 bytes, modified in-place)
 * @return 0 on success, negative error code on failure
 * 
 * Clamping operations:
 * - private_key[0] &= 252  (clear bits 0, 1)
 * - private_key[55] |= 128 (set bit 7)
 * 
 * Purpose:
 * - Ensures private key is a multiple of 4 (cofactor)
 * - Ensures private key is in valid range [2^447, 2^448 - 1]
 * - Provides uniform implementation across all libraries
 * 
 * @note generate_keypair() performs clamping automatically
 * @note Use this only when loading external/legacy keys
 */
NEXTSSL_PARTIAL_API int
nextssl_partial_dhcm_x448_clamp_private_key(uint8_t *private_key);

/**
 * @brief Check if public key is valid (non-contributory check)
 * 
 * @param public_key Public key to check (56 bytes)
 * @return 1 if likely valid, 0 if definitely invalid
 * 
 * Checks:
 * - Not all-zero (obviously invalid)
 * - Not low-order point (rare but possible)
 * 
 * @warning This is NOT required for X448 security (unlike NIST curves)
 * @warning X448 is designed to work without public key validation
 * @note Provided for compatibility with protocols requiring explicit validation
 * 
 * Use case: When protocol spec requires explicit validation (rare)
 */
NEXTSSL_PARTIAL_API int
nextssl_partial_dhcm_x448_validate_public_key(const uint8_t *public_key);

/**
 * @brief Self-test X448 implementation against RFC 7748 test vectors
 * 
 * @return 0 if all tests pass, negative error code on failure
 * 
 * Tests performed:
 * - RFC 7748 test vectors (scalar multiplication)
 * - Iterated test vectors (1, 1000, 1000000 iterations)
 * - Known-answer tests
 * 
 * @note Should be run during library initialization
 */
NEXTSSL_PARTIAL_API int
nextssl_partial_dhcm_x448_selftest(void);

#ifdef __cplusplus
}
#endif

#endif /* NEXTSSL_PARTIAL_DHCM_X448_H */

/**
 * Implementation Notes:
 * 
 * 1. Curve448 Equation (Goldilocks curve):
 *    Montgomery curve: y^2 = x^3 + 156326x^2 + x (mod 2^448 - 2^224 - 1)
 *    X448 uses x-coordinate only (Montgomery ladder)
 * 
 * 2. X448 Function:
 *    X448(k, u) = x-coordinate of k * (u, v) on Curve448
 *    Basepoint: u = 5
 *    Public key: X448(private_key, 5)
 *    Shared secret: X448(our_private, peer_public)
 * 
 * 3. Private Key Clamping (RFC 7748 Section 5):
 *    - Set bits 0, 1 to 0 (multiple of 4, cofactor)
 *    - Set bit 447 to 1 (range [2^447, 2^448))
 *    - Ensures uniform behavior across implementations
 *    - Prevents small-subgroup attacks
 * 
 * 4. No Public Key Validation Needed:
 *    - Cofactor clearing built into protocol
 *    - Small-subgroup attacks prevented by clamping
 *    - Invalid points map to valid result (no error on bad input)
 *    - Same advantage as X25519
 * 
 * 5. Constant-Time Implementation:
 *    - Montgomery ladder algorithm (inherently constant-time)
 *    - No secret-dependent branches or memory accesses
 *    - Protects against timing attacks
 *    - Critical for security (must be verified)
 * 
 * 6. All-Zero Check:
 *    - Shared secret should NEVER be all-zero
 *    - If it is, indicates contributory behavior failure
 *    - Check and reject prevents potential attacks
 * 
 * 7. Use with Ed448:
 *    - X448: Key agreement (ECDH)
 *    - Ed448: Digital signatures (EdDSA)
 *    - Often used together (same curve, different operations)
 *    - Higher security than X25519/Ed25519 combo
 * 
 * 8. Performance:
 *    - ~20,000-30,000 operations/sec on typical x64 CPU
 *    - ~3x slower than X25519 (larger field, more computation)
 *    - Still fast enough for most applications
 *    - Cache-timing resistant
 * 
 * 9. Security Level:
 *    - 224-bit security (Curve448 "Goldilocks")
 *    - Equivalent to AES-224, SHA-384
 *    - Post-quantum: Grover's algorithm requires 2^112 queries
 *    - Safe for long-term keys (20+ years)
 * 
 * 10. When to use X448 vs X25519:
 *     - X25519: Default choice for most applications
 *     - X448: High-security scenario, long-term keys, paranoid mode
 *     - Consider PQC (ML-KEM) for post-quantum security
 * 
 * SECURITY AUDIT NOTES:
 * - [ ] Verify constant-time implementation (Montgomery ladder)
 * - [ ] Check private key clamping in generate_keypair()
 * - [ ] Validate all-zero shared secret rejection
 * - [ ] Test RFC 7748 test vectors (including iterated tests)
 * - [ ] Ensure no secret-dependent branches
 * - [ ] Verify secure memory wiping after key agreement
 * - [ ] Check field arithmetic is mod 2^448 - 2^224 - 1
 */
