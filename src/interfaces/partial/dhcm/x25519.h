/**
 * @file x25519.h
 * @brief Layer 1 (Partial) - X25519 (Curve25519 ECDH) Interface
 * 
 * @visibility HIDDEN (NEXTSSL_PARTIAL_API)
 * @layer 1
 * @category dhcm
 * @subcategory x25519
 * 
 * This interface provides X25519 key agreement (Curve25519 ECDH) as specified in RFC 7748.
 * X25519 is a modern, high-speed elliptic curve Diffie-Hellman function.
 * 
 * Security properties:
 * - 128-bit security level
 * - Constant-time implementation (no timing side-channels)
 * - No public key validation required (built-in cofactor clearing)
 * - Simpler and faster than NIST P-256
 * - Widely deployed (TLS 1.3, SSH, WireGuard, Signal)
 * 
 * @warning X25519 alone does NOT authenticate parties - combine with signatures (Ed25519)
 * @warning Use KDF (e.g., HKDF) to derive session keys from shared secret
 * @warning Never reuse ephemeral keys
 * 
 * Advantages over NIST curves:
 * - Constant-time by design (no secret-dependent branches)
 * - No point validation needed (cofactor clearing built-in)
 * - Faster than P-256 (montgomery curve arithmetic)
 * - Smaller keys (32 bytes vs 65 bytes for P-256 uncompressed)
 * - Simpler implementation (less error-prone)
 * 
 * Thread safety: All functions are thread-safe (stateless operations).
 */

#ifndef NEXTSSL_PARTIAL_DHCM_X25519_H
#define NEXTSSL_PARTIAL_DHCM_X25519_H

#include <stddef.h>
#include <stdint.h>
#include "../../config.h"

#ifdef __cplusplus
extern "C" {
#endif

/* ========================================================================
 * X25519 Constants
 * ======================================================================== */

#define NEXTSSL_X25519_KEY_SIZE     32    /**< X25519 key size (private, public, shared) */
#define NEXTSSL_X25519_SECRET_SIZE  32    /**< X25519 shared secret size */

/* ========================================================================
 * X25519 Key Generation
 * ======================================================================== */

/**
 * @brief Generate X25519 keypair
 * 
 * @param public_key Output buffer for public key (32 bytes)
 * @param private_key Output buffer for private key (32 bytes)
 * @return 0 on success, negative error code on failure
 * 
 * @warning public_key MUST be 32 bytes
 * @warning private_key MUST be 32 bytes
 * @warning Private key MUST be kept secret and destroyed after use
 * 
 * Key generation:
 * - Private key: 32 random bytes (clamped according to RFC 7748)
 * - Public key: X25519(private_key, basepoint=9)
 * 
 * Private key clamping (automatic):
 * - Clear bits 0, 1, 2 of first byte
 * - Clear bit 7 of last byte
 * - Set bit 6 of last byte
 * 
 * @note Uses DRBG for key generation (cryptographically secure)
 * @note Clamping is performed internally - caller receives clamped key
 */
NEXTSSL_PARTIAL_API int
nextssl_partial_dhcm_x25519_generate_keypair(
    uint8_t *public_key,
    uint8_t *private_key
);

/**
 * @brief Derive X25519 public key from private key
 * 
 * @param public_key Output buffer for public key (32 bytes)
 * @param private_key Private key (32 bytes, must be clamped)
 * @return 0 on success, negative error code on failure
 * 
 * @warning public_key MUST be 32 bytes
 * @warning private_key MUST be 32 bytes and properly clamped
 * 
 * Computation:
 * - public_key = X25519(private_key, basepoint=9)
 * 
 * Use case: When you have a stored private key and need to compute public key
 * 
 * @note If private_key was generated by generate_keypair(), it's already clamped
 * @note If loading external key, ensure proper clamping (or use clamp function)
 */
NEXTSSL_PARTIAL_API int
nextssl_partial_dhcm_x25519_public_key(
    uint8_t *public_key,
    const uint8_t *private_key
);

/* ========================================================================
 * X25519 Key Agreement
 * ======================================================================== */

/**
 * @brief Compute X25519 shared secret
 * 
 * @param shared_secret Output buffer for shared secret (32 bytes)
 * @param private_key Our private key (32 bytes, must be clamped)
 * @param peer_public_key Peer's public key (32 bytes)
 * @return 0 on success, negative error code on failure
 * 
 * @warning shared_secret MUST be 32 bytes
 * @warning private_key MUST be 32 bytes and properly clamped
 * @warning peer_public_key MUST be 32 bytes
 * @warning NO public key validation is performed (not needed for X25519)
 * @warning ALWAYS use KDF (e.g., HKDF) to derive session keys from shared_secret
 * 
 * Computation:
 * - shared_secret = X25519(private_key, peer_public_key)
 * 
 * Error conditions:
 * - Returns error if shared secret is all-zero (contributory behavior failure)
 * - Returns error if inputs are NULL
 * 
 * Security notes:
 * - No public key validation needed (cofactor clearing built-in)
 * - Constant-time implementation (no timing side-channels)
 * - Small-subgroup attacks prevented by clamping + cofactor clearing
 * 
 * Example usage:
 * ```c
 * uint8_t our_private[32], our_public[32];
 * uint8_t peer_public[32], shared_secret[32];
 * 
 * // Generate our keypair
 * nextssl_partial_dhcm_x25519_generate_keypair(our_public, our_private);
 * 
 * // Send our_public to peer, receive peer_public
 * 
 * // Compute shared secret
 * nextssl_partial_dhcm_x25519_compute(shared_secret, our_private, peer_public);
 * 
 * // Derive session key using HKDF
 * uint8_t session_key[32];
 * nextssl_partial_core_kdf_hkdf(NEXTSSL_HKDF_SHA256,
 *     NULL, 0,  // no salt
 *     shared_secret, 32,
 *     "session key v1", 15,
 *     session_key, 32);
 * 
 * // Wipe shared secret and private key
 * nextssl_partial_core_buffer_secure_zero(shared_secret, 32);
 * nextssl_partial_core_buffer_secure_zero(our_private, 32);
 * ```
 */
NEXTSSL_PARTIAL_API int
nextssl_partial_dhcm_x25519_compute(
    uint8_t *shared_secret,
    const uint8_t *private_key,
    const uint8_t *peer_public_key
);

/* ========================================================================
 * X25519 Utility Functions
 * ======================================================================== */

/**
 * @brief Clamp X25519 private key according to RFC 7748
 * 
 * @param private_key Private key to clamp (32 bytes, modified in-place)
 * @return 0 on success, negative error code on failure
 * 
 * Clamping operations:
 * - private_key[0] &= 248  (clear bits 0, 1, 2)
 * - private_key[31] &= 127 (clear bit 7)
 * - private_key[31] |= 64  (set bit 6)
 * 
 * Purpose:
 * - Ensures private key is a multiple of 8 (cofactor)
 * - Ensures private key is in valid range [2^254, 2^255 - 1]
 * - Provides uniform implementation across all libraries
 * 
 * @note generate_keypair() performs clamping automatically
 * @note Use this only when loading external/legacy keys
 */
NEXTSSL_PARTIAL_API int
nextssl_partial_dhcm_x25519_clamp_private_key(uint8_t *private_key);

/**
 * @brief Check if public key is valid (non-contributory check)
 * 
 * @param public_key Public key to check (32 bytes)
 * @return 1 if likely valid, 0 if definitely invalid
 * 
 * Checks:
 * - Not all-zero (obviously invalid)
 * - Not low-order point (rare but possible)
 * 
 * @warning This is NOT required for X25519 security (unlike NIST curves)
 * @warning X25519 is designed to work without public key validation
 * @note Provided for compatibility with protocols requiring explicit validation
 * 
 * Use case: When protocol spec requires explicit validation (rare)
 */
NEXTSSL_PARTIAL_API int
nextssl_partial_dhcm_x25519_validate_public_key(const uint8_t *public_key);

/**
 * @brief Self-test X25519 implementation against RFC 7748 test vectors
 * 
 * @return 0 if all tests pass, negative error code on failure
 * 
 * Tests performed:
 * - RFC 7748 test vectors (scalar multiplication)
 * - Iterated test vectors (1, 1000, 1000000 iterations)
 * - Known-answer tests
 * 
 * @note Should be run during library initialization
 */
NEXTSSL_PARTIAL_API int
nextssl_partial_dhcm_x25519_selftest(void);

#ifdef __cplusplus
}
#endif

#endif /* NEXTSSL_PARTIAL_DHCM_X25519_H */

/**
 * Implementation Notes:
 * 
 * 1. Curve25519 Equation:
 *    Montgomery curve: y^2 = x^3 + 486662x^2 + x (mod 2^255 - 19)
 *    X25519 uses x-coordinate only (Montgomery ladder)
 * 
 * 2. X25519 Function:
 *    X25519(k, u) = x-coordinate of k * (u, v) on Curve25519
 *    Basepoint: u = 9
 *    Public key: X25519(private_key, 9)
 *    Shared secret: X25519(our_private, peer_public)
 * 
 * 3. Private Key Clamping (RFC 7748 Section 5):
 *    - Set bits 0, 1, 2 to 0 (multiple of 8, cofactor)
 *    - Set bit 254 to 1, bit 255 to 0 (range [2^254, 2^255))
 *    - Ensures uniform behavior across implementations
 *    - Prevents small-subgroup attacks
 * 
 * 4. No Public Key Validation Needed:
 *    - Cofactor clearing built into protocol
 *    - Small-subgroup attacks prevented by clamping
 *    - Invalid points map to valid result (no error on bad input)
 *    - Major advantage over NIST curves
 * 
 * 5. Constant-Time Implementation:
 *    - Montgomery ladder algorithm (inherently constant-time)
 *    - No secret-dependent branches or memory accesses
 *    - Protects against timing attacks
 *    - Critical for security (must be verified)
 * 
 * 6. All-Zero Check:
 *    - Shared secret should NEVER be all-zero
 *    - If it is, indicates contributory behavior failure
 *    - Check and reject prevents potential attacks
 * 
 * 7. Use with Ed25519:
 *    - X25519: Key agreement (ECDH)
 *    - Ed25519: Digital signatures (ECDSA equivalent)
 *    - Often used together (same curve, different operations)
 *    - TLS 1.3, SSH, Signal, WireGuard all use both
 * 
 * 8. Performance:
 *    - ~70,000 operations/sec on typical x64 CPU
 *    - 2-3x faster than NIST P-256
 *    - Cache-timing resistant
 * 
 * SECURITY AUDIT NOTES:
 * - [ ] Verify constant-time implementation (Montgomery ladder)
 * - [ ] Check private key clamping in generate_keypair()
 * - [ ] Validate all-zero shared secret rejection
 * - [ ] Test RFC 7748 test vectors (including iterated tests)
 * - [ ] Ensure no secret-dependent branches
 * - [ ] Verify secure memory wiping after key agreement
 * - [ ] Check field arithmetic is mod 2^255 - 19
 */
